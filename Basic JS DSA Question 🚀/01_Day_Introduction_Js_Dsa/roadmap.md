# DSA Roadmap: From Basics to Advanced in JavaScript

This repository outlines a comprehensive roadmap for mastering Data Structures and Algorithms (DSA) using JavaScript. The roadmap is divided into four weeks, covering foundational topics, advanced data structures, algorithms, and practical projects. Each section includes detailed questions to enhance your understanding and skills.

## Week 1: JavaScript Fundamentals

### Day 01: JavaScript Basics
1. **Variable Declaration**: Declare variables of types: string, number, boolean, null, undefined. Print each variable along with its type.
2. **Swapping Variables**: Write a function to swap two variables without using a third variable. Demonstrate it with examples.
3. **Area Calculation**: Create a function that takes width and height as parameters and returns the area of a rectangle.
4. **Sign Check**: Implement a function that takes a number and returns "Positive", "Negative", or "Zero".
5. **Temperature Converter**: Write a function that converts Fahrenheit to Celsius and prints the result.

### Day 02: Control Structures
6. **Largest of Three Numbers**: Write a program that takes three numbers as input and returns the largest among them.
7. **Multiplication Table**: Create a program that prints the multiplication table of a given number up to 10.
8. **Count Numbers**: Implement a program that counts from 1 to 100, but skips all multiples of 5.
9. **Leap Year Check**: Write a function that checks if a given year is a leap year.
10. **Number Guessing Game**: Create a simple guessing game where the user has to guess a randomly generated number.

### Day 03: Functions
11. **Factorial Calculation**: Write a recursive function to calculate the factorial of a given number.
12. **Maximum in Array**: Create a function that finds the maximum number in an array of integers.
13. **Vowel Check**: Implement a function that checks if a string contains only vowels.
14. **Sum of Even Numbers**: Write a function that returns the sum of all even numbers in a given array.
15. **First Non-Repeating Character**: Create a function that finds and returns the first non-repeating character in a string.

### Day 04: Arrays
16. **Remove Duplicates**: Write a function that removes duplicates from an array and returns a new array.
17. **Array Rotation**: Implement a function that rotates an array to the right by a given number of steps.
18. **Second Largest Number**: Create a function that finds the second largest number in an array.
19. **Reverse Array**: Write a program that reverses an array in place without using additional arrays.
20. **Merge Sorted Arrays**: Implement a function that merges two sorted arrays into one sorted array.

### Day 05: Objects
21. **Book Object**: Create an object that represents a book with properties like title, author, and year. Add a method to display book info.
22. **Keys of Object**: Write a function that takes an object as input and returns an array of its keys.
23. **Update Object Property**: Implement a method that updates a property of an object and returns the updated object.
24. **Check Property**: Create a function that checks if an object has a specific property and returns true or false.
25. **Deep Clone Object**: Write a function that deep clones an object using recursion.

### Day 06: String Manipulation
26. **Count Vowels**: Write a function that counts the number of vowels in a given string.
27. **Capitalize Words**: Create a program that capitalizes the first letter of each word in a string.
28. **Replace Spaces**: Implement a function that replaces all spaces in a string with underscores.
29. **Reverse String**: Write a function that reverses a string without using built-in methods.
30. **Longest Substring**: Create a function that finds the longest substring without repeating characters.

### Day 07: ES6 Features
31. **Destructuring**: Demonstrate the use of destructuring to extract values from arrays and objects.
32. **Spread Operator**: Write a function that merges two arrays using the spread operator.
33. **Promise Handling**: Create a function that returns a promise that resolves after 2 seconds.
34. **Async/Await**: Implement a function that fetches data from a public API using async/await.
35. **Template Literals**: Write a program that uses template literals to format a greeting message.

## Week 2: Data Structures

### Day 08: Introduction to Data Structures
36. **Definition Comparison**: Explain the differences between arrays and linked lists in terms of memory and access time.
37. **Hash Table Advantages**: Discuss the advantages and disadvantages of using a hash table for data storage.
38. **Time Complexity Chart**: Create a chart comparing time complexities of various data structures (arrays, linked lists, hash tables).
39. **Queue Simulation**: Write a program that simulates a simple queue using an array, with enqueue and dequeue operations.
40. **Element Frequency**: Implement a function that counts the occurrences of each element in an array and returns an object.

### Day 09: Arrays (Advanced)
41. **Array Intersection**: Write a function that finds the intersection of two arrays and returns a new array.
42. **First Missing Positive**: Create a function that returns the first missing positive integer from an unsorted array.
43. **Array Rotation Check**: Implement a function that checks if one array is a rotation of another.
44. **Sort Strings by Length**: Write a program that sorts an array of strings by their lengths.
45. **Group by Property**: Create a function that groups an array of objects by a specific property (e.g., by age).

### Day 10: Linked Lists
46. **Singly Linked List Implementation**: Create a singly linked list and implement methods for insertion and deletion.
47. **Cycle Detection**: Write a function that detects if a linked list has a cycle using Floyd's Tortoise and Hare algorithm.
48. **Find Middle Node**: Implement a method to find the middle node of a linked list.
49. **Reverse Linked List**: Create a function that reverses a linked list iteratively and recursively.
50. **Merge Two Sorted Lists**: Write a function to merge two sorted linked lists into one sorted linked list.

### Day 11: Stacks
51. **Stack Implementation**: Implement a stack using an array and include push, pop, and peek methods.
52. **Postfix Evaluation**: Write a function to evaluate a postfix expression using a stack.
53. **Balanced Parentheses**: Create a function that checks for balanced parentheses in an expression using a stack.
54. **Sort Stack Using Recursion**: Implement a function that sorts a stack using recursion.
55. **Min Element Retrieval**: Write a program to implement a stack that supports retrieving the minimum element in constant time.

### Day 12: Queues
56. **Queue Implementation**: Create a queue using an array and implement enqueue, dequeue, and peek methods.
57. **Circular Queue**: Write a function to simulate a circular queue.
58. **Priority Queue Using Heap**: Implement a priority queue using a binary heap.
59. **Reverse Order Using Queue**: Create a function that uses a queue to reverse the order of elements.
60. **Task Scheduler Using Queues**: Write a program that implements a task scheduler using queues.

### Day 13: Hash Tables
61. **Basic Hash Table**: Implement a simple hash table with methods for inserting and retrieving values.
62. **Anagram Check**: Write a function that checks if two strings are anagrams using a hash table.
63. **Non-Repeating Character**: Create a function that finds the first non-repeating character in a string using a hash table.
64. **Element Frequency Counting**: Implement a method to count the frequency of elements in an array using a hash table.
65. **Two Sum Problem**: Write a function to find two numbers in an array that add up to a target sum using a hash table.

### Day 14: Trees
66. **Binary Tree Implementation**: Create a binary tree and implement traversal methods (inorder, preorder, postorder).
67. **Find Height of Tree**: Write a function that calculates the height of a binary tree.
68. **Check Balanced Tree**: Implement a method to check if a binary tree is balanced.
69. **Level Order Traversal**: Create a function that performs level order traversal of a binary tree.
70. **Lowest Common Ancestor**: Write a program to find the lowest common ancestor of two nodes in a binary search tree.

## Week 3: Algorithms

### Day 15: Sorting Algorithms
71. **Selection Sort Implementation**: Write a function that implements the selection sort algorithm and explain its time complexity.
72. **Insertion Sort Implementation**: Create a program that sorts an array using insertion sort.
73. **Merge Sort Implementation**: Implement a function that performs merge sort and explain the merging process.
74. **Quick Sort Implementation**: Write a function that implements quick sort and discuss its average and worst-case time complexities.
75. **Sort Objects by Property**: Create a function that sorts an array of objects based on a specific property (e.g., age).

### Day 16: Advanced Sorting
76. **Counting Sort**: Implement counting sort for a given range of integers and explain its limitations.
77. **Radix Sort**: Write a function that sorts an array of numbers using radix sort.
78. **Heap Sort Implementation**: Create a program that implements heap sort and explain the heapification process.
79. **Stable Sorting**: Write a program that demonstrates a stable sort and discuss its significance in sorting algorithms.
80. **Binary Search**: Implement a function that performs a binary search on a sorted array and explain its time complexity.

### Day 17: Searching Algorithms
81. **Linear Search Implementation**: Write a function that performs linear search on an array.
82. **Recursive Binary Search**: Create a program that performs binary search recursively on a sorted array.
83. **First Occurrence in Sorted Array**: Write a function that finds the index of the first occurrence of an element in a sorted array.
84. **Search in Rotated Sorted Array**: Implement a function that searches for an element in a rotated sorted array.
85. **Count Occurrences in Sorted Array**: Create a program that counts the occurrences of an element in a sorted array using binary search.

### Day 18: Recursion
86. **Fibonacci Series**: Write a recursive function to compute the Fibonacci series up to a certain number.
87. **Tower of Hanoi**: Create a function that solves the Tower of Hanoi problem and explains the recursive strategy.
88. **Generate Subsets**: Implement a function that generates all subsets of a set using recursion.
89. **Calculate Power**: Write a recursive algorithm to calculate the power of a number (base^exponent).
90. **All Permutations of a String**: Create a function that finds all permutations of a string using recursion.

### Day 19: Dynamic Programming
91. **Longest Common Subsequence**: Write a function that solves the longest common subsequence problem using dynamic programming.
92. **Minimum Coin Change**: Create a program that calculates the minimum number of coins needed to make change for a given amount.
93. **0/1 Knapsack Problem**: Implement a dynamic programming solution for the 0/1 knapsack problem.
94. **Maximum Sum of Non-Adjacent Elements**: Write a function to find the maximum sum of non-adjacent elements in an array.
95. **Edit Distance**: Create a program that calculates the edit distance between two strings using dynamic programming.

### Day 20: Backtracking
96. **N-Queens Problem**: Implement the N-Queens problem using backtracking and explain the solution strategy.
97. **Sudoku Solver**: Write a function that solves a Sudoku puzzle using backtracking.
98. **Generate Combinations**: Create a program that generates all combinations of a set of numbers.
99. **Maze Path Finding**: Implement a function that finds all possible paths in a maze using backtracking.
100. **Generate Valid Parentheses**: Write a function that generates all valid combinations of parentheses for a given number of pairs.

### Day 21: Graphs
101. **Graph Representation**: Create a graph using an adjacency list and implement methods for adding vertices and edges.
102. **Depth-First Search (DFS)**: Write a function that performs DFS on a graph and prints the traversal order.
103. **Breadth-First Search (BFS)**: Implement BFS on a graph and explain the queue-based traversal mechanism.
104. **Detect Cycles in Directed Graph**: Create a function that detects cycles in a directed graph using DFS.
105. **Shortest Path in Unweighted Graph**: Write a function that finds the shortest path in an unweighted graph using BFS.

## Week 4: Advanced Topics

### Day 22: Advanced Graph Algorithms
106. **Prim's Algorithm**: Implement Prim's algorithm to find the minimum spanning tree of a graph.
107. **Kruskal's Algorithm**: Write a function to implement Kruskal's algorithm for finding the minimum spanning tree.
108. **Strongly Connected Components**: Create a program that finds strongly connected components in a directed graph using Kosaraju's algorithm.
109. **Articulation Points**: Write a function to find all articulation points in a graph using DFS.
110. **Bellman-Ford Algorithm**: Implement the Bellman-Ford algorithm to find the shortest path in a weighted graph.

### Day 23: Greedy Algorithms
111. **Fractional Knapsack Problem**: Solve the fractional knapsack problem using a greedy approach and explain the rationale.
112. **Minimum Number of Platforms**: Write a function that calculates the minimum number of platforms required for a train station given arrival and departure times.
113. **Job Scheduling**: Create a program that schedules the maximum number of jobs within a given time frame based on their start and finish times.
114. **Activity Selection Problem**: Implement the activity selection problem using a greedy algorithm to maximize the number of activities.
115. **Minimum Cost to Connect Ropes**: Write a function to calculate the minimum cost to connect all ropes, given their lengths.

### Day 24: Advanced Data Structures
116. **Trie Implementation**: Implement a Trie data structure to store a set of strings and demonstrate its usage.
117. **Segment Tree**: Create a program that uses a Segment Tree for range queries (e.g., sum, minimum).
118. **Disjoint Set Union**: Write a function that implements the Union-Find data structure with path compression.
119. **Min-Heap Implementation**: Create a min-heap and demonstrate its insertion and deletion operations.
120. **AVL Tree Implementation**: Implement a balanced binary search tree (AVL Tree) with rotation operations.

### Day 25: Bit Manipulation
121. **Count Set Bits**: Write a function that counts the number of set bits (1s) in an integer.
122. **Check Opposite Signs**: Implement a program that checks if two integers have opposite signs using bitwise operators.
123. **Swap Without Temporary Variable**: Create a function to swap two numbers without using a temporary variable.
124. **Find Non-Repeating Element**: Write a function that finds the only non-repeating element in an array where every other element repeats.
125. **Clear the ith Bit**: Implement a program that clears the ith bit of an integer.

### Day 26: Final Projects
126. **Library Management System**: Plan and implement a project that combines multiple data structures and algorithms (e.g., a library management system).
127. **Simple Game**: Create a simple game that uses algorithms learned (e.g., tic-tac-toe or a basic text-based RPG).
128. **Sorting Algorithms Visualization**: Write a web app that visualizes various sorting algorithms in action.
129. **Personal Budget Tracker**: Implement a personal budget tracker using objects and arrays to manage income and expenses.
130. **Task Management Tool**: Create a task management tool that uses queues to manage tasks and display their status.

### Day 27-28: Review and Practice
131. **LeetCode Challenges**: Solve a series of problems on LeetCode or HackerRank focused on previously covered topics.
132. **Concept Review**: Review the key concepts of each data structure and algorithm and summarize them.
133. **Time Complexity Summary**: Create a summary sheet with time complexities for each algorithm and data structure.
134. **Peer Discussion**: Discuss solutions to common problems with peers or mentors for collaborative learning.
135. **Interview Preparation**: Prepare for coding interviews by practicing common interview questions from platforms like Pramp or Interviewing.io.

---

This roadmap is designed to help you build a strong foundation in DSA and prepare you for technical interviews and real-world applications. Happy coding!
